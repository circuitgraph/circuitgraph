<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.4" />
<title>circuitgraph.transform API documentation</title>
<meta name="description" content="Functions for transforming circuits" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/highlight.min.js" integrity="sha256-eOgo0OtLL4cdq7RdwRUiGKLX9XsIJ7nGhWEKbohmVAQ=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>circuitgraph.transform</code></h1>
</header>
<section id="section-intro">
<p>Functions for transforming circuits</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Functions for transforming circuits&#34;&#34;&#34;

import subprocess
from tempfile import NamedTemporaryFile
import os

import networkx as nx

from circuitgraph import Circuit
from circuitgraph.utils import clog2
from circuitgraph.logic import popcount
from circuitgraph.io import verilog_to_circuit, circuit_to_verilog


def copy(c):
    &#34;&#34;&#34;
    Returns copy of a circuit.

    Parameters
    ----------
    c : Circuit
            Input circuit.

    Returns
    -------
    Circuit
            Circuit copy.

    &#34;&#34;&#34;
    return Circuit(graph=c.graph.copy(), name=c.name, blackboxes=c.blackboxes.copy())


def strip_io(c):
    &#34;&#34;&#34;
    Removes circuit&#39;s outputs and converts inputs to buffers for easy
    instantiation.

    Parameters
    ----------
    c : Circuit
            Input circuit.

    Returns
    -------
    Circuit
            Circuit with removed io
    &#34;&#34;&#34;
    g = c.graph.copy()
    for o in c.io():
        g.nodes[o][&#34;type&#34;] = &#34;buf&#34;

    return Circuit(graph=g, name=c.name, blackboxes=c.blackboxes.copy())


def strip_outputs(c):
    &#34;&#34;&#34;
    Removes a circuit&#39;s outputs for easy
    instantiation.

    Parameters
    ----------
    c : Circuit
            Input circuit.

    Returns
    -------
    Circuit
            Circuit with removed io
    &#34;&#34;&#34;
    g = c.graph.copy()
    for o in c.outputs():
        g.nodes[o][&#34;type&#34;] = &#34;buf&#34;

    return Circuit(graph=g, name=c.name, blackboxes=c.blackboxes.copy())


def strip_inputs(c):
    &#34;&#34;&#34;
    Converts inputs to buffers for easy
    instantiation.

    Parameters
    ----------
    c : Circuit
            Input circuit.

    Returns
    -------
    Circuit
            Circuit with removed io
    &#34;&#34;&#34;
    g = c.graph.copy()
    for i in c.inputs():
        g.nodes[i][&#34;type&#34;] = &#34;buf&#34;

    return Circuit(graph=g, name=c.name, blackboxes=c.blackboxes.copy())


def strip_blackboxes(c):
    &#34;&#34;&#34;
    Converts blackboxes to io.

    Parameters
    ----------
    c : Circuit
            Input circuit.

    Returns
    -------
    Circuit
            Circuit with removed blackboxes.
    &#34;&#34;&#34;
    g = c.graph.copy()
    bb_pins = []
    for n in c.filter_type(&#34;bb_input&#34;):
        g.nodes[n][&#34;type&#34;] = &#34;output&#34;
        bb_pins.append(n)
    for n in c.filter_type(&#34;bb_output&#34;):
        g.nodes[n][&#34;type&#34;] = &#34;input&#34;
        bb_pins.append(n)

    # rename nodes
    mapping = {n: n.replace(&#34;.&#34;, &#34;_&#34;) for n in bb_pins}
    for k in mapping.values():
        if k in g:
            raise ValueError(f&#34;Overlapping blackbox name: {k}&#34;)
    nx.relabel_nodes(g, mapping, copy=False)

    return Circuit(graph=g, name=c.name)


def relabel(c):
    &#34;&#34;&#34;
    Builds copy with relabeled nodes.

    Parameters
    ----------
    c : Circuit
            Input circuit.
    mapping : dict of str:str
            Relabeling of nodes.

    Returns
    -------
    Circuit
            Circuit with removed blackboxes.
    &#34;&#34;&#34;
    g = nx.relabel_nodes(g, mapping)
    return Circuit(graph=g, name=c.name, blackboxes=c.blackboxes.copy())


def syn(
    c,
    engine=&#34;yosys&#34;,
    suppress_output=False,
    stdout_file=None,
    stderr_file=None,
    working_dir=&#34;.&#34;,
):
    &#34;&#34;&#34;
    Synthesizes the circuit using yosys or genus.

    Parameters
    ----------
    c : Circuit
            Circuit to synthesize.
    engine : str
            Synthesis tool to use (&#39;genus&#39;, &#39;dc&#39;, or &#39;yosys&#39;)
    suppress_output: bool
            If True, synthesis stdout will not be printed.
    stdout_file: file or str or None
            If defined, synthesis stdout will be directed to this file instead
            of being printed.
    output_file: file or str or None
            If defined, synthesis stderr will be written to this file instead
            of being printed.
    working_dir: str
            The path to run synthesis from. If using genus, this will effect
            where the genus run files are stored.

    Returns
    -------
    Circuit
            Synthesized circuit.
    &#34;&#34;&#34;
    verilog = circuit_to_verilog(c)

    with NamedTemporaryFile(
        prefix=&#34;circuitgraph_synthesis_input&#34;, suffix=&#34;.v&#34;
    ) as tmp_in:
        tmp_in.write(bytes(verilog, &#34;ascii&#34;))
        tmp_in.flush()
        with NamedTemporaryFile(
            prefix=&#34;circuitgraph_synthesis_output&#34;, suffix=&#34;.v&#34;
        ) as tmp_out:
            if engine == &#34;genus&#34;:
                try:
                    lib_path = os.environ[&#34;CIRCUITGRAPH_GENUS_LIBRARY_PATH&#34;]
                except KeyError:
                    raise ValueError(
                        &#34;In order to run synthesis with Genus, &#34;
                        &#34;please set the &#34;
                        &#34;CIRCUITGRAPH_GENUS_LIBRARY_PATH &#34;
                        &#34;variable in your os environment to the &#34;
                        &#34;path to the tech library to use&#34;
                    )
                cmd = [
                    &#34;genus&#34;,
                    &#34;-no_gui&#34;,
                    &#34;-execute&#34;,
                    &#34;set_db / .library &#34;
                    f&#34;{lib_path};\n&#34;
                    f&#34;read_hdl -sv {tmp_in.name};\n&#34;
                    &#34;elaborate;\n&#34;
                    &#34;set_db syn_generic_effort high;\n&#34;
                    &#34;syn_generic;\n&#34;
                    &#34;syn_map;\n&#34;
                    &#34;syn_opt;\n&#34;
                    f&#39;redirect {tmp_out.name} &#34;write_hdl -generic&#34;;\n&#39;
                    &#34;exit;&#34;,
                ]
            elif engine == &#34;dc&#34;:
                cmd = [
                    &#34;dc_shell-t&#34;,
                    &#34;-no_gui&#34;,
                    &#34;-x&#34;,
                    f&#34;read_file {tmp_in.name}\n&#34;
                    &#34;link;\n&#34;
                    &#34;uniquify;\n&#34;
                    &#34;check_design;\n&#34;
                    &#34;compile -map_effort high;\n&#34;
                    f&#34;write -format verilog -output {tmp_out.name};\n&#34;
                    &#34;exit;&#34;,
                ]
            elif engine == &#34;yosys&#34;:
                cmd = [
                    &#34;yosys&#34;,
                    &#34;-p&#34;,
                    f&#34;read_verilog {tmp_in.name}; &#34;
                    &#34;synth; &#34;
                    f&#34;write_verilog -noattr {tmp_out.name}&#34;,
                ]
            else:
                raise ValueError(&#34;synthesis engine must be yosys or genus&#34;)

            if suppress_output and not stdout_file:
                stdout = subprocess.DEVNULL
            elif stdout_file:
                stdout = open(stdout_file, &#34;w&#34;)
            else:
                stdout = None
            if stderr_file:
                stderr = open(stderr_file, &#34;w&#34;)
            else:
                stderr = None
            subprocess.run(cmd, stdout=stdout, stderr=stderr, cwd=working_dir)
            if stdout_file:
                stdout.close()
            if stderr_file:
                stderr.close()

            output_netlist = tmp_out.read().decode(&#34;utf-8&#34;)

    return verilog_to_circuit(output_netlist, c.name)


def ternary(c):
    &#34;&#34;&#34;
    Encodes the circuit with ternary values

    Parameters
    ----------
    c : Circuit
            Circuit to encode.

    Returns
    -------
    Circuit
            Encoded circuit.

    &#34;&#34;&#34;
    if c.blackboxes:
        raise ValueError(f&#34;{c.name} contains a blackbox&#34;)
    t = copy(c)

    # add dual nodes
    for n in c:
        if c.type(n) in [&#34;and&#34;, &#34;nand&#34;]:
            t.add(f&#34;{n}_x&#34;, &#34;and&#34;)
            t.add(
                f&#34;{n}_x_in_fi&#34;,
                &#34;or&#34;,
                fanout=f&#34;{n}_x&#34;,
                fanin=[f&#34;{p}_x&#34; for p in c.fanin(n)],
            )
            t.add(f&#34;{n}_0_not_in_fi&#34;, &#34;nor&#34;, fanout=f&#34;{n}_x&#34;)

            for p in c.fanin(n):
                t.add(
                    f&#34;{p}_is_0&#34;, &#34;nor&#34;, fanout=f&#34;{n}_0_not_in_fi&#34;, fanin=[p, f&#34;{p}_x&#34;]
                )

        elif c.type(n) in [&#34;or&#34;, &#34;nor&#34;]:
            t.add(f&#34;{n}_x&#34;, &#34;and&#34;)
            t.add(
                f&#34;{n}_x_in_fi&#34;,
                &#34;or&#34;,
                fanout=f&#34;{n}_x&#34;,
                fanin=[f&#34;{p}_x&#34; for p in c.fanin(n)],
            )
            t.add(f&#34;{n}_1_not_in_fi&#34;, &#34;nor&#34;, fanout=f&#34;{n}_x&#34;)

            for p in c.fanin(n):
                t.add(f&#34;{p}_is_1&#34;, &#34;and&#34;, fanout=f&#34;{n}_1_not_in_fi&#34;, fanin=p)
                t.add(f&#34;{p}_not_x&#34;, &#34;not&#34;, fanout=f&#34;{p}_is_1&#34;, fanin=f&#34;{p}_x&#34;)

        elif c.type(n) in [&#34;buf&#34;, &#34;not&#34;]:
            p = c.fanin(n).pop()
            t.add(f&#34;{n}_x&#34;, &#34;buf&#34;, fanin=f&#34;{p}_x&#34;)

        elif c.type(n) in [&#34;output&#34;]:
            p = c.fanin(n).pop()
            t.add(f&#34;{n}_x&#34;, &#34;output&#34;, fanin=f&#34;{p}_x&#34;)

        elif c.type(n) in [&#34;xor&#34;, &#34;xnor&#34;]:
            t.add(f&#34;{n}_x&#34;, &#34;or&#34;, fanin=(f&#34;{p}_x&#34; for p in c.fanin(n)))

        elif c.type(n) in [&#34;0&#34;, &#34;1&#34;]:
            t.add(f&#34;{n}_x&#34;, &#34;0&#34;)

        elif c.type(n) in [&#34;input&#34;]:
            t.add(f&#34;{n}_x&#34;, &#34;input&#34;)

        else:
            raise ValueError(f&#34;Node {n} has unrecognized type: {c.type(n)}&#34;)

    return t


def miter(c0, c1=None, startpoints=None, endpoints=None):
    &#34;&#34;&#34;
    Creates a miter circuit

    Parameters
    ----------
    c0 : Circuit
            First circuit.
    c1 : Circuit
            Optional second circuit, if None c0 is mitered with itself.
    startpoints : set of str
            Nodes to be tied together, must exist in both circuits.
    endpoints : set of str
            Nodes to be compared, must exist in both circuits.

    Returns
    -------
    Circuit
            Miter circuit.
    &#34;&#34;&#34;
    # check for blackboxes
    if c0.blackboxes:
        raise ValueError(f&#34;{c0.name} contains a blackbox&#34;)
    if c1 and c1.blackboxes:
        raise ValueError(f&#34;{c1.name} contains a blackbox&#34;)

    # clean inputs
    if not c1:
        c1 = c0
    if not startpoints:
        startpoints = c0.startpoints() &amp; c1.startpoints()
    if not endpoints:
        endpoints = c0.endpoints() &amp; c1.endpoints()

    # create miter, relabel
    m = Circuit(name=f&#34;miter_{c0.name}_{c1.name}&#34;)
    m.add_subcircuit(c0, &#34;c0&#34;)
    m.add_subcircuit(c1, &#34;c1&#34;)

    # tie inputs
    for n in startpoints:
        m.add(n, &#34;input&#34;, fanout=[f&#34;c0_{n}&#34;, f&#34;c1_{n}&#34;])

    # compare outputs
    m.add(&#34;miter&#34;, &#34;or&#34;)
    m.add(&#34;sat&#34;, &#34;output&#34;, fanin=&#34;miter&#34;)
    for n in endpoints:
        m.add(f&#34;dif_{n}&#34;, &#34;xor&#34;, fanin=[f&#34;c0_{n}&#34;, f&#34;c1_{n}&#34;], fanout=&#34;miter&#34;)

    return m


def influence_transform(c, n, s):
    &#34;&#34;&#34;
    Creates a circuit to compute sensitivity.

    Parameters
    ----------
    c : Circuit
            Sequential circuit to unroll.
    n : str
            Node to compute influence at.
    s : str
            Startpoint to compute influence for.

    Returns
    -------
    Circuit
            Influence circuit.

    &#34;&#34;&#34;
    # check for blackboxes
    if c.blackboxes:
        raise ValueError(f&#34;{c.name} contains a blackbox&#34;)

    # check if s is in startpoints
    sp = c.startpoints(n)
    if s not in sp:
        raise ValueError(f&#34;{s} is not in startpoints of {n}&#34;)

    # get input cone
    fi_nodes = c.transitive_fanin(n) | set([n])
    sub_c = Circuit(&#34;sub_cone&#34;, c.graph.subgraph(fi_nodes).copy())

    # create two copies of sub circuit, share inputs except s
    infl = Circuit(name=f&#34;infl_{s}_on_{n}&#34;)
    infl.add_subcircuit(sub_c, &#34;c0&#34;)
    infl.add_subcircuit(sub_c, &#34;c1&#34;)
    for g in sp:
        if g != s:
            infl.add(g, &#34;input&#34;, fanout=[f&#34;c0_{g}&#34;, f&#34;c1_{g}&#34;])
        else:
            infl.add(f&#34;not_{g}&#34;, &#34;not&#34;, fanout=f&#34;c1_{s}&#34;)
            infl.add(g, &#34;input&#34;, fanout=[f&#34;c0_{g}&#34;, f&#34;not_{g}&#34;])
    infl.add(&#34;dif&#34;, &#34;xor&#34;, fanin=[f&#34;c0_{n}&#34;, f&#34;c1_{n}&#34;])
    infl.add(&#34;sat&#34;, &#34;output&#34;, fanin=&#34;dif&#34;)

    return infl


def sensitivity_transform(c, n):
    &#34;&#34;&#34;
    Creates a circuit to compute sensitivity.

    Parameters
    ----------
    c : Circuit
            Sequential circuit to unroll.
    n : str
            Node to compute sensitivity at.

    Returns
    -------
    Circuit
            Sensitivity circuit.

    &#34;&#34;&#34;

    # check for blackboxes
    if c.blackboxes:
        raise ValueError(f&#34;{c.name} contains a blackbox&#34;)

    # check for startpoints
    startpoints = c.startpoints(n)
    if len(startpoints) &lt; 1:
        raise ValueError(f&#34;{n} has no startpoints&#34;)

    # get input cone
    fi_nodes = c.transitive_fanin(n) | set([n])
    sub_c = Circuit(graph=c.graph.subgraph(fi_nodes).copy())

    # create sensitivity circuit
    sen = Circuit()
    sen.add_subcircuit(sub_c, &#34;orig&#34;)
    for s in startpoints:
        sen.add(s, &#34;input&#34;, fanout=f&#34;orig_{s}&#34;)

    # add popcount
    sen.add_subcircuit(popcount(len(startpoints)), &#34;pc&#34;)

    # add inverted input copies
    for i, s0 in enumerate(startpoints):
        sen.add_subcircuit(sub_c, f&#34;inv_{s0}&#34;)

        # connect inputs
        for s1 in startpoints:
            if s0 != s1:
                sen.connect(s1, f&#34;inv_{s0}_{s1}&#34;)
            else:
                # connect inverted input
                sen.set_type(f&#34;inv_{s0}_{s1}&#34;, &#34;not&#34;)
                sen.connect(s0, f&#34;inv_{s0}_{s1}&#34;)

        # compare to orig
        sen.add(
            f&#34;dif_{s0}&#34;,
            &#34;xor&#34;,
            fanin=[f&#34;orig_{n}&#34;, f&#34;inv_{s0}_{n}&#34;],
            fanout=f&#34;pc_in_{i}&#34;,
        )
        sen.add(f&#34;dif_out_{s0}&#34;, &#34;output&#34;, fanin=f&#34;dif_{s0}&#34;)

    # instantiate population count
    for o in range(clog2(len(startpoints) + 1)):
        sen.add(f&#34;sen_out_{o}&#34;, &#34;output&#34;, fanin=f&#34;pc_out_{o}&#34;)

    return sen


def sensitization_transform(c, n):
    &#34;&#34;&#34;
    Creates a circuit to sensitize a node to an endpoint.

    Parameters
    ----------
    c : Circuit
            Input circuit.
    n : str
            Node to sensitize.

    Returns
    -------
    Circuit
            Output circuit.

    &#34;&#34;&#34;
    # create miter
    m = miter(c)
    m.name = f&#34;{c.name}_sensitized_{n}&#34;

    # flip node in c1
    m.disconnect(m.fanin(f&#34;c1_{n}&#34;), f&#34;c1_{n}&#34;)
    m.set_type(f&#34;c1_{n}&#34;, &#34;not&#34;)
    m.connect(f&#34;c0_{n}&#34;, f&#34;c1_{n}&#34;)

    return m</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="circuitgraph.transform.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>c)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns copy of a circuit.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>c</code></strong> :&ensp;<code>Circuit</code></dt>
<dd>Input circuit.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Circuit</code></dt>
<dd>Circuit copy.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy(c):
    &#34;&#34;&#34;
    Returns copy of a circuit.

    Parameters
    ----------
    c : Circuit
            Input circuit.

    Returns
    -------
    Circuit
            Circuit copy.

    &#34;&#34;&#34;
    return Circuit(graph=c.graph.copy(), name=c.name, blackboxes=c.blackboxes.copy())</code></pre>
</details>
</dd>
<dt id="circuitgraph.transform.influence_transform"><code class="name flex">
<span>def <span class="ident">influence_transform</span></span>(<span>c, n, s)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a circuit to compute sensitivity.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>c</code></strong> :&ensp;<code>Circuit</code></dt>
<dd>Sequential circuit to unroll.</dd>
<dt><strong><code>n</code></strong> :&ensp;<code>str</code></dt>
<dd>Node to compute influence at.</dd>
<dt><strong><code>s</code></strong> :&ensp;<code>str</code></dt>
<dd>Startpoint to compute influence for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Circuit</code></dt>
<dd>Influence circuit.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def influence_transform(c, n, s):
    &#34;&#34;&#34;
    Creates a circuit to compute sensitivity.

    Parameters
    ----------
    c : Circuit
            Sequential circuit to unroll.
    n : str
            Node to compute influence at.
    s : str
            Startpoint to compute influence for.

    Returns
    -------
    Circuit
            Influence circuit.

    &#34;&#34;&#34;
    # check for blackboxes
    if c.blackboxes:
        raise ValueError(f&#34;{c.name} contains a blackbox&#34;)

    # check if s is in startpoints
    sp = c.startpoints(n)
    if s not in sp:
        raise ValueError(f&#34;{s} is not in startpoints of {n}&#34;)

    # get input cone
    fi_nodes = c.transitive_fanin(n) | set([n])
    sub_c = Circuit(&#34;sub_cone&#34;, c.graph.subgraph(fi_nodes).copy())

    # create two copies of sub circuit, share inputs except s
    infl = Circuit(name=f&#34;infl_{s}_on_{n}&#34;)
    infl.add_subcircuit(sub_c, &#34;c0&#34;)
    infl.add_subcircuit(sub_c, &#34;c1&#34;)
    for g in sp:
        if g != s:
            infl.add(g, &#34;input&#34;, fanout=[f&#34;c0_{g}&#34;, f&#34;c1_{g}&#34;])
        else:
            infl.add(f&#34;not_{g}&#34;, &#34;not&#34;, fanout=f&#34;c1_{s}&#34;)
            infl.add(g, &#34;input&#34;, fanout=[f&#34;c0_{g}&#34;, f&#34;not_{g}&#34;])
    infl.add(&#34;dif&#34;, &#34;xor&#34;, fanin=[f&#34;c0_{n}&#34;, f&#34;c1_{n}&#34;])
    infl.add(&#34;sat&#34;, &#34;output&#34;, fanin=&#34;dif&#34;)

    return infl</code></pre>
</details>
</dd>
<dt id="circuitgraph.transform.miter"><code class="name flex">
<span>def <span class="ident">miter</span></span>(<span>c0, c1=None, startpoints=None, endpoints=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a miter circuit</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>c0</code></strong> :&ensp;<code>Circuit</code></dt>
<dd>First circuit.</dd>
<dt><strong><code>c1</code></strong> :&ensp;<code>Circuit</code></dt>
<dd>Optional second circuit, if None c0 is mitered with itself.</dd>
<dt><strong><code>startpoints</code></strong> :&ensp;<code>set</code> of <code>str</code></dt>
<dd>Nodes to be tied together, must exist in both circuits.</dd>
<dt><strong><code>endpoints</code></strong> :&ensp;<code>set</code> of <code>str</code></dt>
<dd>Nodes to be compared, must exist in both circuits.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Circuit</code></dt>
<dd>Miter circuit.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def miter(c0, c1=None, startpoints=None, endpoints=None):
    &#34;&#34;&#34;
    Creates a miter circuit

    Parameters
    ----------
    c0 : Circuit
            First circuit.
    c1 : Circuit
            Optional second circuit, if None c0 is mitered with itself.
    startpoints : set of str
            Nodes to be tied together, must exist in both circuits.
    endpoints : set of str
            Nodes to be compared, must exist in both circuits.

    Returns
    -------
    Circuit
            Miter circuit.
    &#34;&#34;&#34;
    # check for blackboxes
    if c0.blackboxes:
        raise ValueError(f&#34;{c0.name} contains a blackbox&#34;)
    if c1 and c1.blackboxes:
        raise ValueError(f&#34;{c1.name} contains a blackbox&#34;)

    # clean inputs
    if not c1:
        c1 = c0
    if not startpoints:
        startpoints = c0.startpoints() &amp; c1.startpoints()
    if not endpoints:
        endpoints = c0.endpoints() &amp; c1.endpoints()

    # create miter, relabel
    m = Circuit(name=f&#34;miter_{c0.name}_{c1.name}&#34;)
    m.add_subcircuit(c0, &#34;c0&#34;)
    m.add_subcircuit(c1, &#34;c1&#34;)

    # tie inputs
    for n in startpoints:
        m.add(n, &#34;input&#34;, fanout=[f&#34;c0_{n}&#34;, f&#34;c1_{n}&#34;])

    # compare outputs
    m.add(&#34;miter&#34;, &#34;or&#34;)
    m.add(&#34;sat&#34;, &#34;output&#34;, fanin=&#34;miter&#34;)
    for n in endpoints:
        m.add(f&#34;dif_{n}&#34;, &#34;xor&#34;, fanin=[f&#34;c0_{n}&#34;, f&#34;c1_{n}&#34;], fanout=&#34;miter&#34;)

    return m</code></pre>
</details>
</dd>
<dt id="circuitgraph.transform.relabel"><code class="name flex">
<span>def <span class="ident">relabel</span></span>(<span>c)</span>
</code></dt>
<dd>
<div class="desc"><p>Builds copy with relabeled nodes.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>c</code></strong> :&ensp;<code>Circuit</code></dt>
<dd>Input circuit.</dd>
<dt><strong><code>mapping</code></strong> :&ensp;<code>dict</code> of <code>str:str</code></dt>
<dd>Relabeling of nodes.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Circuit</code></dt>
<dd>Circuit with removed blackboxes.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def relabel(c):
    &#34;&#34;&#34;
    Builds copy with relabeled nodes.

    Parameters
    ----------
    c : Circuit
            Input circuit.
    mapping : dict of str:str
            Relabeling of nodes.

    Returns
    -------
    Circuit
            Circuit with removed blackboxes.
    &#34;&#34;&#34;
    g = nx.relabel_nodes(g, mapping)
    return Circuit(graph=g, name=c.name, blackboxes=c.blackboxes.copy())</code></pre>
</details>
</dd>
<dt id="circuitgraph.transform.sensitivity_transform"><code class="name flex">
<span>def <span class="ident">sensitivity_transform</span></span>(<span>c, n)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a circuit to compute sensitivity.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>c</code></strong> :&ensp;<code>Circuit</code></dt>
<dd>Sequential circuit to unroll.</dd>
<dt><strong><code>n</code></strong> :&ensp;<code>str</code></dt>
<dd>Node to compute sensitivity at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Circuit</code></dt>
<dd>Sensitivity circuit.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sensitivity_transform(c, n):
    &#34;&#34;&#34;
    Creates a circuit to compute sensitivity.

    Parameters
    ----------
    c : Circuit
            Sequential circuit to unroll.
    n : str
            Node to compute sensitivity at.

    Returns
    -------
    Circuit
            Sensitivity circuit.

    &#34;&#34;&#34;

    # check for blackboxes
    if c.blackboxes:
        raise ValueError(f&#34;{c.name} contains a blackbox&#34;)

    # check for startpoints
    startpoints = c.startpoints(n)
    if len(startpoints) &lt; 1:
        raise ValueError(f&#34;{n} has no startpoints&#34;)

    # get input cone
    fi_nodes = c.transitive_fanin(n) | set([n])
    sub_c = Circuit(graph=c.graph.subgraph(fi_nodes).copy())

    # create sensitivity circuit
    sen = Circuit()
    sen.add_subcircuit(sub_c, &#34;orig&#34;)
    for s in startpoints:
        sen.add(s, &#34;input&#34;, fanout=f&#34;orig_{s}&#34;)

    # add popcount
    sen.add_subcircuit(popcount(len(startpoints)), &#34;pc&#34;)

    # add inverted input copies
    for i, s0 in enumerate(startpoints):
        sen.add_subcircuit(sub_c, f&#34;inv_{s0}&#34;)

        # connect inputs
        for s1 in startpoints:
            if s0 != s1:
                sen.connect(s1, f&#34;inv_{s0}_{s1}&#34;)
            else:
                # connect inverted input
                sen.set_type(f&#34;inv_{s0}_{s1}&#34;, &#34;not&#34;)
                sen.connect(s0, f&#34;inv_{s0}_{s1}&#34;)

        # compare to orig
        sen.add(
            f&#34;dif_{s0}&#34;,
            &#34;xor&#34;,
            fanin=[f&#34;orig_{n}&#34;, f&#34;inv_{s0}_{n}&#34;],
            fanout=f&#34;pc_in_{i}&#34;,
        )
        sen.add(f&#34;dif_out_{s0}&#34;, &#34;output&#34;, fanin=f&#34;dif_{s0}&#34;)

    # instantiate population count
    for o in range(clog2(len(startpoints) + 1)):
        sen.add(f&#34;sen_out_{o}&#34;, &#34;output&#34;, fanin=f&#34;pc_out_{o}&#34;)

    return sen</code></pre>
</details>
</dd>
<dt id="circuitgraph.transform.sensitization_transform"><code class="name flex">
<span>def <span class="ident">sensitization_transform</span></span>(<span>c, n)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a circuit to sensitize a node to an endpoint.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>c</code></strong> :&ensp;<code>Circuit</code></dt>
<dd>Input circuit.</dd>
<dt><strong><code>n</code></strong> :&ensp;<code>str</code></dt>
<dd>Node to sensitize.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Circuit</code></dt>
<dd>Output circuit.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sensitization_transform(c, n):
    &#34;&#34;&#34;
    Creates a circuit to sensitize a node to an endpoint.

    Parameters
    ----------
    c : Circuit
            Input circuit.
    n : str
            Node to sensitize.

    Returns
    -------
    Circuit
            Output circuit.

    &#34;&#34;&#34;
    # create miter
    m = miter(c)
    m.name = f&#34;{c.name}_sensitized_{n}&#34;

    # flip node in c1
    m.disconnect(m.fanin(f&#34;c1_{n}&#34;), f&#34;c1_{n}&#34;)
    m.set_type(f&#34;c1_{n}&#34;, &#34;not&#34;)
    m.connect(f&#34;c0_{n}&#34;, f&#34;c1_{n}&#34;)

    return m</code></pre>
</details>
</dd>
<dt id="circuitgraph.transform.strip_blackboxes"><code class="name flex">
<span>def <span class="ident">strip_blackboxes</span></span>(<span>c)</span>
</code></dt>
<dd>
<div class="desc"><p>Converts blackboxes to io.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>c</code></strong> :&ensp;<code>Circuit</code></dt>
<dd>Input circuit.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Circuit</code></dt>
<dd>Circuit with removed blackboxes.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def strip_blackboxes(c):
    &#34;&#34;&#34;
    Converts blackboxes to io.

    Parameters
    ----------
    c : Circuit
            Input circuit.

    Returns
    -------
    Circuit
            Circuit with removed blackboxes.
    &#34;&#34;&#34;
    g = c.graph.copy()
    bb_pins = []
    for n in c.filter_type(&#34;bb_input&#34;):
        g.nodes[n][&#34;type&#34;] = &#34;output&#34;
        bb_pins.append(n)
    for n in c.filter_type(&#34;bb_output&#34;):
        g.nodes[n][&#34;type&#34;] = &#34;input&#34;
        bb_pins.append(n)

    # rename nodes
    mapping = {n: n.replace(&#34;.&#34;, &#34;_&#34;) for n in bb_pins}
    for k in mapping.values():
        if k in g:
            raise ValueError(f&#34;Overlapping blackbox name: {k}&#34;)
    nx.relabel_nodes(g, mapping, copy=False)

    return Circuit(graph=g, name=c.name)</code></pre>
</details>
</dd>
<dt id="circuitgraph.transform.strip_inputs"><code class="name flex">
<span>def <span class="ident">strip_inputs</span></span>(<span>c)</span>
</code></dt>
<dd>
<div class="desc"><p>Converts inputs to buffers for easy
instantiation.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>c</code></strong> :&ensp;<code>Circuit</code></dt>
<dd>Input circuit.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Circuit</code></dt>
<dd>Circuit with removed io</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def strip_inputs(c):
    &#34;&#34;&#34;
    Converts inputs to buffers for easy
    instantiation.

    Parameters
    ----------
    c : Circuit
            Input circuit.

    Returns
    -------
    Circuit
            Circuit with removed io
    &#34;&#34;&#34;
    g = c.graph.copy()
    for i in c.inputs():
        g.nodes[i][&#34;type&#34;] = &#34;buf&#34;

    return Circuit(graph=g, name=c.name, blackboxes=c.blackboxes.copy())</code></pre>
</details>
</dd>
<dt id="circuitgraph.transform.strip_io"><code class="name flex">
<span>def <span class="ident">strip_io</span></span>(<span>c)</span>
</code></dt>
<dd>
<div class="desc"><p>Removes circuit's outputs and converts inputs to buffers for easy
instantiation.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>c</code></strong> :&ensp;<code>Circuit</code></dt>
<dd>Input circuit.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Circuit</code></dt>
<dd>Circuit with removed io</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def strip_io(c):
    &#34;&#34;&#34;
    Removes circuit&#39;s outputs and converts inputs to buffers for easy
    instantiation.

    Parameters
    ----------
    c : Circuit
            Input circuit.

    Returns
    -------
    Circuit
            Circuit with removed io
    &#34;&#34;&#34;
    g = c.graph.copy()
    for o in c.io():
        g.nodes[o][&#34;type&#34;] = &#34;buf&#34;

    return Circuit(graph=g, name=c.name, blackboxes=c.blackboxes.copy())</code></pre>
</details>
</dd>
<dt id="circuitgraph.transform.strip_outputs"><code class="name flex">
<span>def <span class="ident">strip_outputs</span></span>(<span>c)</span>
</code></dt>
<dd>
<div class="desc"><p>Removes a circuit's outputs for easy
instantiation.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>c</code></strong> :&ensp;<code>Circuit</code></dt>
<dd>Input circuit.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Circuit</code></dt>
<dd>Circuit with removed io</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def strip_outputs(c):
    &#34;&#34;&#34;
    Removes a circuit&#39;s outputs for easy
    instantiation.

    Parameters
    ----------
    c : Circuit
            Input circuit.

    Returns
    -------
    Circuit
            Circuit with removed io
    &#34;&#34;&#34;
    g = c.graph.copy()
    for o in c.outputs():
        g.nodes[o][&#34;type&#34;] = &#34;buf&#34;

    return Circuit(graph=g, name=c.name, blackboxes=c.blackboxes.copy())</code></pre>
</details>
</dd>
<dt id="circuitgraph.transform.syn"><code class="name flex">
<span>def <span class="ident">syn</span></span>(<span>c, engine='yosys', suppress_output=False, stdout_file=None, stderr_file=None, working_dir='.')</span>
</code></dt>
<dd>
<div class="desc"><p>Synthesizes the circuit using yosys or genus.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>c</code></strong> :&ensp;<code>Circuit</code></dt>
<dd>Circuit to synthesize.</dd>
<dt><strong><code>engine</code></strong> :&ensp;<code>str</code></dt>
<dd>Synthesis tool to use ('genus', 'dc', or 'yosys')</dd>
<dt><strong><code>suppress_output</code></strong> :&ensp;<code>bool</code></dt>
<dd>If True, synthesis stdout will not be printed.</dd>
<dt><strong><code>stdout_file</code></strong> :&ensp;<code>file</code> or <code>str</code> or <code>None</code></dt>
<dd>If defined, synthesis stdout will be directed to this file instead
of being printed.</dd>
<dt><strong><code>output_file</code></strong> :&ensp;<code>file</code> or <code>str</code> or <code>None</code></dt>
<dd>If defined, synthesis stderr will be written to this file instead
of being printed.</dd>
<dt><strong><code>working_dir</code></strong> :&ensp;<code>str</code></dt>
<dd>The path to run synthesis from. If using genus, this will effect
where the genus run files are stored.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Circuit</code></dt>
<dd>Synthesized circuit.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def syn(
    c,
    engine=&#34;yosys&#34;,
    suppress_output=False,
    stdout_file=None,
    stderr_file=None,
    working_dir=&#34;.&#34;,
):
    &#34;&#34;&#34;
    Synthesizes the circuit using yosys or genus.

    Parameters
    ----------
    c : Circuit
            Circuit to synthesize.
    engine : str
            Synthesis tool to use (&#39;genus&#39;, &#39;dc&#39;, or &#39;yosys&#39;)
    suppress_output: bool
            If True, synthesis stdout will not be printed.
    stdout_file: file or str or None
            If defined, synthesis stdout will be directed to this file instead
            of being printed.
    output_file: file or str or None
            If defined, synthesis stderr will be written to this file instead
            of being printed.
    working_dir: str
            The path to run synthesis from. If using genus, this will effect
            where the genus run files are stored.

    Returns
    -------
    Circuit
            Synthesized circuit.
    &#34;&#34;&#34;
    verilog = circuit_to_verilog(c)

    with NamedTemporaryFile(
        prefix=&#34;circuitgraph_synthesis_input&#34;, suffix=&#34;.v&#34;
    ) as tmp_in:
        tmp_in.write(bytes(verilog, &#34;ascii&#34;))
        tmp_in.flush()
        with NamedTemporaryFile(
            prefix=&#34;circuitgraph_synthesis_output&#34;, suffix=&#34;.v&#34;
        ) as tmp_out:
            if engine == &#34;genus&#34;:
                try:
                    lib_path = os.environ[&#34;CIRCUITGRAPH_GENUS_LIBRARY_PATH&#34;]
                except KeyError:
                    raise ValueError(
                        &#34;In order to run synthesis with Genus, &#34;
                        &#34;please set the &#34;
                        &#34;CIRCUITGRAPH_GENUS_LIBRARY_PATH &#34;
                        &#34;variable in your os environment to the &#34;
                        &#34;path to the tech library to use&#34;
                    )
                cmd = [
                    &#34;genus&#34;,
                    &#34;-no_gui&#34;,
                    &#34;-execute&#34;,
                    &#34;set_db / .library &#34;
                    f&#34;{lib_path};\n&#34;
                    f&#34;read_hdl -sv {tmp_in.name};\n&#34;
                    &#34;elaborate;\n&#34;
                    &#34;set_db syn_generic_effort high;\n&#34;
                    &#34;syn_generic;\n&#34;
                    &#34;syn_map;\n&#34;
                    &#34;syn_opt;\n&#34;
                    f&#39;redirect {tmp_out.name} &#34;write_hdl -generic&#34;;\n&#39;
                    &#34;exit;&#34;,
                ]
            elif engine == &#34;dc&#34;:
                cmd = [
                    &#34;dc_shell-t&#34;,
                    &#34;-no_gui&#34;,
                    &#34;-x&#34;,
                    f&#34;read_file {tmp_in.name}\n&#34;
                    &#34;link;\n&#34;
                    &#34;uniquify;\n&#34;
                    &#34;check_design;\n&#34;
                    &#34;compile -map_effort high;\n&#34;
                    f&#34;write -format verilog -output {tmp_out.name};\n&#34;
                    &#34;exit;&#34;,
                ]
            elif engine == &#34;yosys&#34;:
                cmd = [
                    &#34;yosys&#34;,
                    &#34;-p&#34;,
                    f&#34;read_verilog {tmp_in.name}; &#34;
                    &#34;synth; &#34;
                    f&#34;write_verilog -noattr {tmp_out.name}&#34;,
                ]
            else:
                raise ValueError(&#34;synthesis engine must be yosys or genus&#34;)

            if suppress_output and not stdout_file:
                stdout = subprocess.DEVNULL
            elif stdout_file:
                stdout = open(stdout_file, &#34;w&#34;)
            else:
                stdout = None
            if stderr_file:
                stderr = open(stderr_file, &#34;w&#34;)
            else:
                stderr = None
            subprocess.run(cmd, stdout=stdout, stderr=stderr, cwd=working_dir)
            if stdout_file:
                stdout.close()
            if stderr_file:
                stderr.close()

            output_netlist = tmp_out.read().decode(&#34;utf-8&#34;)

    return verilog_to_circuit(output_netlist, c.name)</code></pre>
</details>
</dd>
<dt id="circuitgraph.transform.ternary"><code class="name flex">
<span>def <span class="ident">ternary</span></span>(<span>c)</span>
</code></dt>
<dd>
<div class="desc"><p>Encodes the circuit with ternary values</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>c</code></strong> :&ensp;<code>Circuit</code></dt>
<dd>Circuit to encode.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Circuit</code></dt>
<dd>Encoded circuit.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ternary(c):
    &#34;&#34;&#34;
    Encodes the circuit with ternary values

    Parameters
    ----------
    c : Circuit
            Circuit to encode.

    Returns
    -------
    Circuit
            Encoded circuit.

    &#34;&#34;&#34;
    if c.blackboxes:
        raise ValueError(f&#34;{c.name} contains a blackbox&#34;)
    t = copy(c)

    # add dual nodes
    for n in c:
        if c.type(n) in [&#34;and&#34;, &#34;nand&#34;]:
            t.add(f&#34;{n}_x&#34;, &#34;and&#34;)
            t.add(
                f&#34;{n}_x_in_fi&#34;,
                &#34;or&#34;,
                fanout=f&#34;{n}_x&#34;,
                fanin=[f&#34;{p}_x&#34; for p in c.fanin(n)],
            )
            t.add(f&#34;{n}_0_not_in_fi&#34;, &#34;nor&#34;, fanout=f&#34;{n}_x&#34;)

            for p in c.fanin(n):
                t.add(
                    f&#34;{p}_is_0&#34;, &#34;nor&#34;, fanout=f&#34;{n}_0_not_in_fi&#34;, fanin=[p, f&#34;{p}_x&#34;]
                )

        elif c.type(n) in [&#34;or&#34;, &#34;nor&#34;]:
            t.add(f&#34;{n}_x&#34;, &#34;and&#34;)
            t.add(
                f&#34;{n}_x_in_fi&#34;,
                &#34;or&#34;,
                fanout=f&#34;{n}_x&#34;,
                fanin=[f&#34;{p}_x&#34; for p in c.fanin(n)],
            )
            t.add(f&#34;{n}_1_not_in_fi&#34;, &#34;nor&#34;, fanout=f&#34;{n}_x&#34;)

            for p in c.fanin(n):
                t.add(f&#34;{p}_is_1&#34;, &#34;and&#34;, fanout=f&#34;{n}_1_not_in_fi&#34;, fanin=p)
                t.add(f&#34;{p}_not_x&#34;, &#34;not&#34;, fanout=f&#34;{p}_is_1&#34;, fanin=f&#34;{p}_x&#34;)

        elif c.type(n) in [&#34;buf&#34;, &#34;not&#34;]:
            p = c.fanin(n).pop()
            t.add(f&#34;{n}_x&#34;, &#34;buf&#34;, fanin=f&#34;{p}_x&#34;)

        elif c.type(n) in [&#34;output&#34;]:
            p = c.fanin(n).pop()
            t.add(f&#34;{n}_x&#34;, &#34;output&#34;, fanin=f&#34;{p}_x&#34;)

        elif c.type(n) in [&#34;xor&#34;, &#34;xnor&#34;]:
            t.add(f&#34;{n}_x&#34;, &#34;or&#34;, fanin=(f&#34;{p}_x&#34; for p in c.fanin(n)))

        elif c.type(n) in [&#34;0&#34;, &#34;1&#34;]:
            t.add(f&#34;{n}_x&#34;, &#34;0&#34;)

        elif c.type(n) in [&#34;input&#34;]:
            t.add(f&#34;{n}_x&#34;, &#34;input&#34;)

        else:
            raise ValueError(f&#34;Node {n} has unrecognized type: {c.type(n)}&#34;)

    return t</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<header>
<img src="circuitgraph.png" alt="" style="margin-bottom: 31px;">
<a class="github-button" href="https://github.com/circuitgraph/circuitgraph"><b>GitHub</b></a>
</header>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="circuitgraph" href="index.html">circuitgraph</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="circuitgraph.transform.copy" href="#circuitgraph.transform.copy">copy</a></code></li>
<li><code><a title="circuitgraph.transform.influence_transform" href="#circuitgraph.transform.influence_transform">influence_transform</a></code></li>
<li><code><a title="circuitgraph.transform.miter" href="#circuitgraph.transform.miter">miter</a></code></li>
<li><code><a title="circuitgraph.transform.relabel" href="#circuitgraph.transform.relabel">relabel</a></code></li>
<li><code><a title="circuitgraph.transform.sensitivity_transform" href="#circuitgraph.transform.sensitivity_transform">sensitivity_transform</a></code></li>
<li><code><a title="circuitgraph.transform.sensitization_transform" href="#circuitgraph.transform.sensitization_transform">sensitization_transform</a></code></li>
<li><code><a title="circuitgraph.transform.strip_blackboxes" href="#circuitgraph.transform.strip_blackboxes">strip_blackboxes</a></code></li>
<li><code><a title="circuitgraph.transform.strip_inputs" href="#circuitgraph.transform.strip_inputs">strip_inputs</a></code></li>
<li><code><a title="circuitgraph.transform.strip_io" href="#circuitgraph.transform.strip_io">strip_io</a></code></li>
<li><code><a title="circuitgraph.transform.strip_outputs" href="#circuitgraph.transform.strip_outputs">strip_outputs</a></code></li>
<li><code><a title="circuitgraph.transform.syn" href="#circuitgraph.transform.syn">syn</a></code></li>
<li><code><a title="circuitgraph.transform.ternary" href="#circuitgraph.transform.ternary">ternary</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.4</a>.</p>
</footer>
</body>
</html>